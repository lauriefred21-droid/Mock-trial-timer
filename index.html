<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#0f1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Mock Trial Timer</title>
  <link rel="manifest" href="manifest.webmanifest" />

  <style>
    :root{
      color-scheme: dark;

      /* Base (keep your navy) */
      --bg0:#070B14;
      --bg1:#0B1220;

      /* Glass */
      --card: rgba(19, 28, 46, 0.62);
      --dock: rgba(10, 16, 30, 0.58);
      --border: rgba(255,255,255,0.12);
      --borderStrong: rgba(255,255,255,0.18);
      --text:#F4F6FA;
      --muted: rgba(244,246,250,0.72);

      /* Accents */
      --blue:#244C8F;
      --blueSoft: rgba(36,76,143,0.22);

      /* Actions */
      --start:#1F6F4A;              /* solid green */
      --pauseBg: rgba(122,28,38,.18);
      --pauseBorder: rgba(146,40,51,.45); /* muted courtroom red */
      --pauseSolid:#7A1C26;
      --reset:#2B3C5A;

      /* Warnings */
      --warn:#C9A23A;      /* muted gold */
      --warnGlow: rgba(201,162,58,.18);
      --over:#922833;      /* muted red */
      --overGlow: rgba(146,40,51,.20);

      /* Glass tuning */
      --blur: 18px;
      --sat: 140%;

      /* Sizing */
      --radius: 18px;
    }

    *{ box-sizing:border-box; -webkit-tap-highlight-color:transparent; }
    html, body{ height:100%; }
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 18% -10%, rgba(36,76,143,0.22), transparent 64%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      color: var(--text);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      touch-action: manipulation;
    }

    /* Accessibility toggles */
    body.reduce-transparency{
      --card: rgba(19, 28, 46, 0.92);
      --dock: rgba(10, 16, 30, 0.92);
      --blur: 0px;
      --sat: 100%;
    }
    body.high-contrast{
      --border: rgba(255,255,255,0.30);
      --borderStrong: rgba(255,255,255,0.38);
      --muted: rgba(244,246,250,0.86);
    }
    body.large-numbers .time.big{ font-size: 80px; }
    body.large-numbers .time.med{ font-size: 60px; }
    @media (max-width:420px){
      body.large-numbers .time.big{ font-size: 66px; }
      body.large-numbers .time.med{ font-size: 50px; }
    }

    @media (prefers-reduced-motion: reduce){
      *{ scroll-behavior:auto !important; }
      .sheet, .backdrop, .toast, header{ transition:none !important; animation:none !important; }
      .card{ transition:none !important; }
    }

    /* Full-width layout */
    .wrap{
      padding: 14px 14px calc(18px + env(safe-area-inset-bottom));
      width: 100%;
      max-width: none; /* full span */
      margin: 0;
    }

    /* Slim top bar */
    header{
      padding: 10px 12px calc(10px + env(safe-area-inset-top));
      position: sticky;
      top: 0;
      z-index: 30;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;

      background: rgba(7, 11, 20, 0.55);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      -webkit-backdrop-filter: blur(var(--blur)) saturate(var(--sat));
    }
    header.auto-hide{
      transition: transform 180ms ease, opacity 180ms ease;
      will-change: transform;
    }
    header.auto-hide.is-hidden{
      transform: translateY(-120%);
      opacity: 0.98;
    }

    .title{
      font-weight: 950;
      letter-spacing: .2px;
      font-size: 14px;
      user-select:none;
      white-space: nowrap;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--borderStrong);
      background: rgba(255,255,255,0.06);
      color: var(--text);
      font-weight: 950;
      font-size: 13px;
      cursor: pointer;
      user-select:none;
      min-height: 44px;
    }
    .pill:active{ transform: scale(0.99); }

    /* Grid */
    .grid{
      display:grid;
      grid-template-columns: 1fr;
      gap: 12px;
      max-width: 1200px; /* optional: keeps cards from stretching absurdly on ultrawide */
      margin: 0 auto;
    }
    @media (min-width: 860px){
      .grid{ grid-template-columns: 1fr 1fr; }
      .span-2{ grid-column: 1 / span 2; }
    }

    .card{
      border: 1px solid var(--border);
      background: var(--card);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 14px 34px rgba(0,0,0,0.42);
      overflow:hidden;
      position:relative;
      backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      -webkit-backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      transition: box-shadow 160ms ease, border-color 160ms ease;
    }
    .card::before{
      content:"";
      position:absolute;
      inset:0;
      background: radial-gradient(700px 260px at 20% 0%, rgba(255,255,255,0.10), transparent 62%);
      pointer-events:none;
      opacity: 0.8;
    }

    /* Whole-card glow states */
    .card.state-running{
      border-color: rgba(36,76,143,0.55);
      box-shadow:
        0 14px 34px rgba(0,0,0,0.42),
        0 0 0 1px rgba(36,76,143,0.18),
        0 0 18px rgba(36,76,143,0.16);
    }
    .card.state-warn{
      border-color: rgba(201,162,58,0.55);
      box-shadow:
        0 14px 34px rgba(0,0,0,0.42),
        0 0 0 1px rgba(201,162,58,0.16),
        0 0 16px rgba(201,162,58,0.14);
    }
    .card.state-over{
      border-color: rgba(146,40,51,0.62);
      box-shadow:
        0 14px 34px rgba(0,0,0,0.42),
        0 0 0 1px rgba(146,40,51,0.18),
        0 0 18px rgba(146,40,51,0.14);
    }

    .label{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap: 12px;
      margin-bottom: 8px;
      position:relative;
    }
    .name{
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .16px;
      opacity: 0.92;
      text-transform: none; /* no small-caps cosplay */
    }
    .hint{
      font-size: 12px;
      font-weight: 800;
      opacity: 0.78;
    }

    .time{
      font-variant-numeric: tabular-nums;
      letter-spacing: .5px;
      user-select:none;
      margin: 10px 0 10px;
      font-weight: 980;
      position:relative;
    }
    .time.big{ font-size: 72px; line-height: 1.0; }
    .time.med{ font-size: 54px; line-height: 1.03; }
    @media (max-width:420px){
      .time.big{ font-size: 58px; }
      .time.med{ font-size: 44px; }
    }

    /* Under-timer label (warnings/overage etc.) */
    .subline{
      margin-top: -2px;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .12px;
      opacity: .92;
      font-variant-numeric: tabular-nums;
      position: relative;
    }
    .subline.muted{ opacity: .72; font-weight: 820; }

    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr auto;
      gap: 10px;
      position:relative;
      margin-top: 10px;
    }

    button{
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 950;
      cursor:pointer;
      user-select:none;
      min-height: 48px;
    }
    button:active{ transform: scale(0.99); }

    button.start{
      background: var(--start);
      border-color: rgba(31,111,74,0.75);
      color: #06130C;
      font-weight: 990;
    }
    button.pause{
      background: var(--pauseBg);
      border-color: var(--pauseBorder);
      color: var(--text);
      font-weight: 980;
    }
    button.reset{
      background: rgba(43,60,90,0.55);
      border-color: rgba(43,60,90,0.72);
      padding: 10px 12px;
      min-height: 44px;
      font-size: 12px;
      font-weight: 900;
      opacity: .95;
    }

    /* Segment selector (AMTA + Custom) */
    .segbar{
      display:flex;
      flex-wrap:wrap;
      gap: 8px;
      margin-top: 10px;
      position: relative;
    }
    .segbtn{
      padding: 10px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      font-weight: 900;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      min-height: 40px;
    }
    .segbtn[aria-pressed="true"]{
      border-color: rgba(36,76,143,0.55);
      background: rgba(36,76,143,0.22);
    }

    /* Objections dock (placed between speech and sides) */
    .dock{
      padding: 12px;
      border-radius: var(--radius);
      border: 1px solid rgba(255,255,255,0.12);
      background: var(--dock);
      backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      -webkit-backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      box-shadow: 0 18px 40px rgba(0,0,0,0.48);
      display:grid;
      gap: 10px;
      position:relative;
    }
    .dock-top{
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      gap:10px;
    }
    .dock-title{
      font-weight: 950;
      letter-spacing: .14px;
    }
    .dock-sub{
      font-size: 12px;
      opacity: .76;
      font-weight: 780;
    }
    .dock-buttons{
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }
    button.objection{
      background: var(--pauseSolid);
      border-color: rgba(146,40,51,0.7);
      color: #150607;
      font-weight: 990;
      min-height: 56px;
      font-size: 16px;
      letter-spacing: .2px;
    }
    button.resume{
      background: rgba(31,111,74,0.82);
      border-color: rgba(31,111,74,0.82);
      color: #07140D;
      font-weight: 990;
      min-height: 56px;
      font-size: 16px;
      letter-spacing: .2px;
    }

    /* Round + log */
    .row2{ display:grid; grid-template-columns: 1fr; gap: 10px; margin-top:10px; }
    @media (min-width:860px){ .row2{ grid-template-columns:1fr 1fr; } }

    button.endround{
      background: rgba(201,162,58,0.92);
      border-color: rgba(201,162,58,0.92);
      color:#141006;
      font-weight: 990;
      min-height: 52px;
    }
    button.export{
      background: rgba(255,255,255,0.92);
      border-color: rgba(255,255,255,0.92);
      color:#0b1020;
      font-weight: 980;
      min-height: 46px;
    }

    .log{
      margin-top: 10px;
      display:grid;
      gap: 8px;
    }
    .loglist{
      list-style:none;
      padding:0;
      margin:0;
      display:grid;
      gap: 8px;
    }
    .logitem{
      display:flex;
      justify-content:space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      font-variant-numeric: tabular-nums;
      font-weight: 850;
      align-items: baseline;
    }
    .logitem .meta{
      opacity: .82;
      font-weight: 820;
      font-size: 12px;
      letter-spacing: .12px;
    }

    .small{
      font-size: 12px;
      opacity: .76;
      line-height: 1.35;
      position:relative;
    }

    /* Mobile layout toggle: keep sides SIDE-BY-SIDE */
    body.mobile-mode .wrap{ padding: 10px 10px calc(14px + env(safe-area-inset-bottom)); }
    body.mobile-mode .grid{ gap: 10px; grid-template-columns: 1fr 1fr; }
    body.mobile-mode .span-2{ grid-column: 1 / span 2; }
    body.mobile-mode .card, body.mobile-mode .dock{ padding: 10px; border-radius: 16px; }
    body.mobile-mode .time.big{ font-size: 50px; margin: 6px 0 10px; }
    body.mobile-mode .time.med{ font-size: 36px; margin: 6px 0 10px; }
    body.mobile-mode .controls{ grid-template-columns: 1fr 1fr; gap: 8px; }
    body.mobile-mode .controls button.reset{ grid-column: 1 / span 2; min-height: 42px; padding: 10px 12px; }
    body.mobile-mode button{ min-height: 46px; padding: 11px 12px; }
    body.mobile-mode button.objection, body.mobile-mode button.resume{ min-height: 54px; font-size: 16px; }
    body.mobile-mode .small{ display:none; }
    body.mobile-mode .loglist{ max-height: 180px; overflow:auto; -webkit-overflow-scrolling: touch; }

    /* Game Day Lock */
    body.game-lock .hide-when-locked{ display:none !important; }
    body.game-lock header{ display:none; }
    .lockbar{
      display:none;
      position: sticky;
      top: 0;
      z-index: 35;
      padding: 10px 12px calc(10px + env(safe-area-inset-top));
      background: rgba(7, 11, 20, 0.55);
      border-bottom: 1px solid rgba(255,255,255,0.08);
      backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      -webkit-backdrop-filter: blur(var(--blur)) saturate(var(--sat));
      align-items:center;
      justify-content:space-between;
      gap: 10px;
    }
    body.game-lock .lockbar{ display:flex; }
    .lockbar .locktitle{ font-weight: 950; font-size: 13px; opacity: .92; }

    /* Options sheet */
    .backdrop{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.38);
      opacity: 0;
      pointer-events: none;
      transition: opacity 160ms ease;
      z-index: 40;
    }
    .backdrop.open{ opacity: 1; pointer-events: auto; }

    .sheet{
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%) translateY(-14px) scale(0.985);
      width: min(560px, calc(100% - 18px));
      max-height: calc(100vh - 20px);
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(16, 37, 71, 0.55);
      backdrop-filter: blur(22px) saturate(155%);
      -webkit-backdrop-filter: blur(22px) saturate(155%);
      box-shadow: 0 30px 70px rgba(0,0,0,0.60);
      opacity: 0;
      pointer-events: none;
      transition: opacity 170ms ease, transform 220ms cubic-bezier(.2,.9,.2,1);
      z-index: 45;
    }
    .sheet.open{
      opacity: 1;
      pointer-events: auto;
      transform: translateX(-50%) translateY(0px) scale(1);
    }
    .sheet-header{
      padding: 14px 14px 10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
      position: sticky;
      top: 0;
      background: rgba(16, 37, 71, 0.35);
      backdrop-filter: blur(22px) saturate(155%);
      -webkit-backdrop-filter: blur(22px) saturate(155%);
      border-bottom: 1px solid rgba(255,255,255,0.10);
    }
    .sheet-title{ font-weight: 980; letter-spacing: .12px; }
    .sheet-close{
      border-radius: 999px;
      padding: 10px 12px;
      min-height: 40px;
      font-size: 12px;
      font-weight: 950;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: var(--text);
      cursor:pointer;
    }
    .sheet-body{ padding: 12px 14px 14px; display:grid; gap: 12px; }
    .sheet-group{
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 18px;
      background: rgba(255,255,255,0.06);
      padding: 12px;
    }
    .group-title{
      font-size: 12px;
      letter-spacing: .14px;
      font-weight: 950;
      opacity: .86;
      margin-bottom: 10px;
    }
    .row{
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }
    .toggle{
      display:inline-flex;
      align-items:center;
      gap: 8px;
      font-weight: 900;
      font-size: 13px;
      opacity: .95;
      user-select:none;
      white-space: nowrap;
    }
    .toggle input{ transform: scale(1.15); }

    .select{
      width: 100%;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.18);
      color: var(--text);
      font-weight: 900;
      font-size: 14px;
    }

    .btnrow{ display:grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
    .btnrow.two{ grid-template-columns: 1fr 1fr; }
    @media (max-width: 420px){ .btnrow.two{ grid-template-columns:1fr; } }

    .danger{
      border-color: rgba(146,40,51,0.55) !important;
      background: rgba(122, 28, 38, 0.24) !important;
    }
    .good{
      border-color: rgba(31,111,74,0.55) !important;
      background: rgba(31,111,74,0.20) !important;
      color: #07140D !important;
      font-weight: 980 !important;
    }

    /* Custom pool editor */
    .poollist{ display:grid; gap:10px; }
    .poolitem{
      border:1px solid rgba(255,255,255,0.12);
      background: rgba(255,255,255,0.06);
      border-radius: 16px;
      padding: 10px;
      display:grid;
      gap: 8px;
    }
    .poolrow{
      display:grid;
      grid-template-columns: 1fr 120px auto;
      gap: 8px;
      align-items:center;
    }
    .poolrow input{
      width: 100%;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(0,0,0,0.18);
      color: var(--text);
      font-weight: 900;
      font-size: 13px;
    }
    .poolrow button{
      min-height: 40px;
      padding: 10px 10px;
      font-size: 12px;
      border-radius: 12px;
    }

    /* Toast + SR live */
    .toast{
      position: fixed;
      left: 50%;
      bottom: calc(14px + env(safe-area-inset-bottom));
      transform: translateX(-50%) translateY(10px);
      background: rgba(0,0,0,0.55);
      border: 1px solid rgba(255,255,255,0.14);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 999px;
      font-weight: 900;
      font-size: 12px;
      opacity: 0;
      pointer-events:none;
      transition: opacity 160ms ease, transform 180ms ease;
      z-index: 60;
      backdrop-filter: blur(14px) saturate(140%);
      -webkit-backdrop-filter: blur(14px) saturate(140%);
    }
    .toast.show{ opacity:1; transform: translateX(-50%) translateY(0px); }

    .sr-only{
      position:absolute;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden;clip:rect(0,0,0,0);
      white-space:nowrap;border:0;
    }

    /* Confirm modal (mode switch) */
    .modal{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 70;
    }
    .modal.open{ display:flex; }
    .modal .panel{
      width: min(520px, calc(100% - 18px));
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(16,37,71,0.62);
      backdrop-filter: blur(22px) saturate(155%);
      -webkit-backdrop-filter: blur(22px) saturate(155%);
      box-shadow: 0 30px 70px rgba(0,0,0,0.62);
      padding: 14px;
    }
    .modal h2{ margin:0 0 6px; font-size:14px; font-weight:980; letter-spacing:.12px; }
    .modal p{ margin:0 0 12px; font-size:12px; opacity:.84; line-height:1.35; font-weight:750; }
  </style>
</head>

<body>
  <header aria-label="Top bar" class="auto-hide" id="topHeader">
    <div class="title">Mock Trial Timer</div>
    <button class="pill" id="optionsBtn" aria-haspopup="dialog" aria-expanded="false">Options</button>
  </header>

  <div class="lockbar" aria-label="Game Day Lock bar">
    <div class="locktitle">Game Day Lock</div>
    <button class="pill" id="unlockBtn">Unlock</button>
  </div>

  <div class="wrap">
    <div class="grid">

      <!-- Current Speech -->
      <section class="card span-2" id="cardSpeech" aria-label="Current Speech">
        <div class="label">
          <div class="name">Current Speech</div>
          <div class="hint" id="speechHint">Stopped</div>
        </div>
        <div class="time big" id="speechTime">00:00</div>
        <div class="subline muted" id="speechSub">Ready</div>

        <div class="controls">
          <button class="start" id="speechStart" aria-label="Start current speech">START ▶</button>
          <button class="pause" id="speechPause" aria-label="Pause current speech">PAUSE ⏸</button>
          <button class="reset" id="speechReset" aria-label="Reset and save current speech">RESET ↺</button>
        </div>

        <div class="segbar" id="segmentBar" style="display:none;" aria-label="Speech type">
          <button class="segbtn" data-seg="opening" aria-pressed="true">Opening</button>
          <button class="segbtn" data-seg="direct" aria-pressed="false">Direct</button>
          <button class="segbtn" data-seg="cross" aria-pressed="false">Cross</button>
          <button class="segbtn" data-seg="closing" aria-pressed="false">Closing</button>
        </div>

        <div class="small">Speech Start/Pause syncs with your selected side.</div>
      </section>

      <!-- Objections Mode (moved up, for thumb speed) -->
      <section class="dock span-2" aria-label="Objections Mode" id="cardObjections">
        <div class="dock-top">
          <div>
            <div class="dock-title">Objections</div>
            <div class="dock-sub">Pauses the active set. Resume returns to the last running set.</div>
          </div>
          <div class="dock-sub" id="runningIndicator">All stopped</div>
        </div>
        <div class="dock-buttons">
          <button class="objection" id="objectionPause" aria-label="Pause active set for objection">OBJECTION ⏸</button>
          <button class="resume" id="objectionResume" aria-label="Resume active set after objection">RESUME ▶</button>
        </div>
      </section>

      <!-- Sides: Prosecution LEFT, Defense RIGHT -->
      <section class="card" id="cardPros" aria-label="Prosecution Total Time">
        <div class="label">
          <div class="name">Prosecution Total Time</div>
          <div class="hint" id="prosHint">Stopped</div>
        </div>
        <div class="time med" id="prosTime">00:00</div>
        <div class="subline muted" id="prosSub">Ready</div>

        <div class="controls">
          <button class="start" id="prosStart" aria-label="Start prosecution total">START ▶</button>
          <button class="pause" id="prosPause" aria-label="Pause prosecution total">PAUSE ⏸</button>
          <button class="reset" id="prosReset" aria-label="Reset prosecution total">RESET ↺</button>
        </div>

        <div id="prosPools" style="display:none; margin-top:12px;"></div>
      </section>

      <section class="card" id="cardDef" aria-label="Defense Total Time">
        <div class="label">
          <div class="name">Defense Total Time</div>
          <div class="hint" id="defHint">Stopped</div>
        </div>
        <div class="time med" id="defTime">00:00</div>
        <div class="subline muted" id="defSub">Ready</div>

        <div class="controls">
          <button class="start" id="defStart" aria-label="Start defense total">START ▶</button>
          <button class="pause" id="defPause" aria-label="Pause defense total">PAUSE ⏸</button>
          <button class="reset" id="defReset" aria-label="Reset defense total">RESET ↺</button>
        </div>

        <div id="defPools" style="display:none; margin-top:12px;"></div>
      </section>

      <!-- Round + Log -->
      <section class="card span-2 hide-when-locked" aria-label="Total Round Time" id="cardRound">
        <div class="label">
          <div class="name">Total Round Time</div>
          <div class="hint" id="roundHint">Stopped</div>
        </div>
        <div class="time med" id="roundTime">00:00</div>
        <div class="subline muted" id="roundSub">Cap 03:00:00</div>

        <div class="controls">
          <button class="start" id="roundStart">START ▶</button>
          <button class="pause" id="roundPause">PAUSE ⏸</button>
          <button class="reset" id="roundReset">RESET ↺</button>
        </div>

        <div class="row2">
          <button class="endround" id="endRoundBtn">End Round (save + stop)</button>
          <button class="export" id="exportBtn">Export Round (2 CSVs)</button>
        </div>

        <div class="log" aria-label="Speech Log">
          <div class="label" style="margin-top:6px;">
            <div class="name">Speech Log</div>
            <div class="hint" id="logHint">No speeches saved yet</div>
          </div>
          <ul class="loglist" id="logList"></ul>
          <div class="small">Export includes an AMTA-style timesheet and an official event record.</div>
        </div>
      </section>

    </div>
  </div>

  <!-- Options sheet -->
  <div class="backdrop" id="backdrop" tabindex="-1" aria-hidden="true"></div>

  <div class="sheet" id="sheet" role="dialog" aria-modal="true" aria-labelledby="sheetTitle" aria-hidden="true">
    <div class="sheet-header">
      <div class="sheet-title" id="sheetTitle">Options</div>
      <button class="sheet-close" id="closeSheetBtn" aria-label="Close options">Close</button>
    </div>

    <div class="sheet-body">
      <div class="sheet-group">
        <div class="group-title">Mode</div>
        <select class="select" id="modeSelect" aria-label="Select mode">
          <option value="free">Free</option>
          <option value="amta">AMTA</option>
          <option value="custom">Custom</option>
        </select>
        <div class="small" style="margin-top:8px;">Switching modes mid-round: reset or log the switch.</div>
      </div>

      <div class="sheet-group">
        <div class="group-title">Your side (Speech sync)</div>
        <div class="row" role="radiogroup" aria-label="Select your side">
          <label class="toggle"><input type="radio" name="role" value="pros" id="rolePros"> Prosecution</label>
          <label class="toggle"><input type="radio" name="role" value="def" id="roleDef"> Defense</label>
        </div>
        <div class="small" style="margin-top:8px;">Prosecution stays left. Defense stays right.</div>
      </div>

      <div class="sheet-group">
        <div class="group-title">Toggles</div>
        <div class="row">
          <label class="toggle"><input id="gameLockToggle" type="checkbox" /> Game Day Lock (essentials only)</label>
          <label class="toggle"><input id="mobileToggle" type="checkbox" /> Mobile Layout (side-by-side)</label>
        </div>
        <div class="row" style="margin-top:10px;">
          <label class="toggle"><input id="wakeToggle" type="checkbox" /> Wake Lock</label>
        </div>
        <div class="small" style="margin-top:8px;">Works offline (airplane mode) once installed/cached.</div>
      </div>

      <div class="sheet-group">
        <div class="group-title">Accessibility</div>
        <div class="row">
          <label class="toggle"><input id="hcToggle" type="checkbox" /> High Contrast</label>
          <label class="toggle"><input id="lnToggle" type="checkbox" /> Large Numbers</label>
        </div>
        <div class="row" style="margin-top:10px;">
          <label class="toggle"><input id="rtToggle" type="checkbox" /> Reduce Transparency</label>
          <label class="toggle"><input id="soundToggle" type="checkbox" /> Sound Cues</label>
        </div>
        <div class="small" style="margin-top:8px;">
          Warnings are always text too (not just color).
        </div>
      </div>

      <div class="sheet-group" id="customGroup" style="display:none;">
        <div class="group-title">Custom Pools</div>
        <div class="small" style="margin-top:-6px; margin-bottom:10px;">
          Create pools with caps (mm:ss). Current Speech segment buttons map to these pools.
        </div>
        <div class="poollist" id="poolList"></div>
        <div class="btnrow two">
          <button id="addPoolBtn">Add Pool</button>
          <button class="danger" id="resetPoolsBtn">Reset Pools</button>
        </div>
      </div>

      <div class="sheet-group">
        <div class="group-title">Round Controls</div>
        <div class="btnrow two">
          <button class="good" id="endRoundFromMenu">End Round</button>
          <button class="danger" id="resetEverythingBtn">Reset Everything</button>
        </div>
        <div class="btnrow">
          <button class="export" id="exportFromMenu">Export Round (2 CSVs)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Confirm modal (mode switch) -->
  <div class="modal" id="confirmModal" aria-hidden="true">
    <div class="backdrop open" style="opacity:1; pointer-events:auto;"></div>
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="confirmTitle">
      <h2 id="confirmTitle">Switch modes?</h2>
      <p id="confirmText">Reset the current round, or switch mid-round and log it.</p>
      <div class="btnrow">
        <button class="danger" id="confirmResetSwitch">Reset round and switch</button>
        <button class="good" id="confirmLogSwitch">Switch mid-round (log it)</button>
        <button id="confirmCancel">Cancel</button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast" role="status" aria-live="polite"></div>
  <div class="sr-only" id="srLive" aria-live="polite"></div>

<script>
/* =========================
   Utilities
========================= */
function nowMs(){ return Date.now(); }
function isoNow(){ return new Date().toISOString(); }
function pad2(n){ return String(n).padStart(2,'0'); }

function formatMsToMMSS(ms){
  ms = Math.max(0, ms);
  const s = Math.floor(ms/1000);
  const m = Math.floor(s/60);
  const r = s%60;
  return `${pad2(m)}:${pad2(r)}`;
}
function formatMsToHHMMSS(ms){
  ms = Math.max(0, ms);
  const s = Math.floor(ms/1000);
  const h = Math.floor(s/3600);
  const m = Math.floor((s%3600)/60);
  const r = s%60;
  return `${pad2(h)}:${pad2(m)}:${pad2(r)}`;
}
function formatOverageMs(msOver){
  const s = Math.floor(Math.abs(msOver)/1000);
  const m = Math.floor(s/60);
  const r = s%60;
  return `+${pad2(m)}:${pad2(r)} over`;
}
function parseCapMMSS(str){
  // mm:ss
  const m = String(str||'').trim().match(/^(\d{1,3}):([0-5]\d)$/);
  if (!m) return null;
  const mm = parseInt(m[1],10);
  const ss = parseInt(m[2],10);
  return (mm*60+ss)*1000;
}
function csvEscape(v){
  const s = String(v ?? '');
  if (/[",\n]/.test(s)) return `"${s.replaceAll('"','""')}"`;
  return s;
}
function downloadTextFile(filename, text, mime='text/plain'){
  const blob = new Blob([text], {type:mime});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  setTimeout(()=>URL.revokeObjectURL(url), 1000);
}
async function shareFilesOrDownload(files){
  const fileObjs = files.map(f => new File([f.content], f.name, {type: f.mime || 'text/csv'}));
  const canShare = !!(navigator.share && navigator.canShare && navigator.canShare({ files: fileObjs }));
  if (canShare){
    await navigator.share({ files: fileObjs, title: 'Mock Trial Round Export' });
    return true;
  }
  for (const f of files) downloadTextFile(f.name, f.content, f.mime || 'text/csv');
  return false;
}

function toast(msg){
  const el = document.getElementById('toast');
  const sr = document.getElementById('srLive');
  el.textContent = msg;
  sr.textContent = msg;
  el.classList.add('show');
  clearTimeout(toast._t);
  toast._t = setTimeout(()=>el.classList.remove('show'), 1400);
}

/* optional sound cue */
function beep(kind){
  if (!state.sound) return;
  try{
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = (kind === 'warn') ? 650 : (kind === 'over' ? 430 : 520);
    g.gain.value = 0.06;
    o.connect(g); g.connect(ctx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); ctx.close(); }, 90);
  }catch{}
}

/* =========================
   Stopwatch (accurate, never auto-runs after refresh)
========================= */
class Stopwatch{
  constructor(key){
    this.key = key;
    this.elapsedMs = 0;
    this.running = false;
    this.startedAtEpoch = 0;
    this._loadElapsedOnly();
  }
  _loadElapsedOnly(){
    try{
      const raw = localStorage.getItem(this.key);
      if (!raw) return;
      const data = JSON.parse(raw);
      this.elapsedMs = data.elapsedMs || 0;
    }catch{}
    this.running = false;
    this.startedAtEpoch = 0;
  }
  _saveElapsedOnly(){ localStorage.setItem(this.key, JSON.stringify({ elapsedMs: this.elapsedMs })); }
  getElapsedMs(){ return this.running ? (this.elapsedMs + (nowMs() - this.startedAtEpoch)) : this.elapsedMs; }
  start(){ if (this.running) return; this.running = true; this.startedAtEpoch = nowMs(); }
  stop(){
    if (!this.running) return;
    this.elapsedMs = this.getElapsedMs();
    this.running = false;
    this.startedAtEpoch = 0;
    this._saveElapsedOnly();
  }
  reset(){
    this.elapsedMs = 0;
    this.running = false;
    this.startedAtEpoch = 0;
    this._saveElapsedOnly();
  }
}

/* =========================
   Storage + state
========================= */
const STORE = {
  role: 'mt_role',
  mode: 'mt_mode',
  mobile: 'mt_mobile_mode',
  lock: 'mt_game_lock',
  wake: 'mt_wake',
  a11y: 'mt_a11y',
  sound: 'mt_sound',
  speechLog: 'mt_speech_log',
  eventLog: 'mt_event_log',
  customPools: 'mt_custom_pools'
};

function loadJSON(key, fallback){
  try{
    const raw = localStorage.getItem(key);
    if (!raw) return fallback;
    return JSON.parse(raw);
  }catch{ return fallback; }
}
function saveJSON(key, obj){ localStorage.setItem(key, JSON.stringify(obj)); }

const state = {
  mode: 'free',
  role: null,
  currentSegment: 'opening',
  currentPoolKey: null,
  sound: false,
};

function getRole(){
  const r = localStorage.getItem(STORE.role);
  return (r === 'def' || r === 'pros') ? r : null;
}
function setRole(r){
  localStorage.setItem(STORE.role, r);
  document.getElementById('rolePros').checked = (r === 'pros');
  document.getElementById('roleDef').checked = (r === 'def');
  state.role = r;
}
function getMode(){
  const m = localStorage.getItem(STORE.mode);
  return (m === 'free' || m === 'amta' || m === 'custom') ? m : 'free';
}
function setMode(m){
  localStorage.setItem(STORE.mode, m);
  document.getElementById('modeSelect').value = m;
  state.mode = m;
}

/* =========================
   Timers
========================= */
const speech = new Stopwatch('mt_speech');
const prosTotal = new Stopwatch('mt_pros_total');
const defTotal  = new Stopwatch('mt_def_total');
const round     = new Stopwatch('mt_round');

/* Round cap (3 hours) */
const ROUND_CAP_MS = 3 * 60 * 60 * 1000;
const ROUND_WARN_MS = 10 * 60 * 1000; // 10 min left warning

/* AMTA caps */
const AMTA_CAPS_MS = {
  openClose: 14 * 60 * 1000,
  direct: 25 * 60 * 1000,
  cross: 25 * 60 * 1000
};
/* AMTA rebuttal max is tracked (no button in segment bar). We track it as a sub-cap when segment=closing and role=pros and user toggles "Rebuttal" from options later if you want.
   For now: we will track "closing cap" (14 pool) correctly; rebuttal max tracking can be added next pass. */
const AMTA_REBUTTAL_MAX_MS = 5 * 60 * 1000;

/* Pools (AMTA + Custom): per-side stopwatches per pool key */
function makePoolStopwatches(prefix, poolKeys){
  const obj = {};
  for (const k of poolKeys) obj[k] = new Stopwatch(`${prefix}_${k}`);
  return obj;
}
const amtaPools = {
  pros: makePoolStopwatches('mt_amta_pros', ['openClose','direct','cross']),
  def:  makePoolStopwatches('mt_amta_def',  ['openClose','direct','cross'])
};

let customPools = loadJSON(STORE.customPools, [
  { id: 'pool1', name: 'Opening/Closing', capMs: 14*60*1000 },
  { id: 'pool2', name: 'Direct/Redirect', capMs: 25*60*1000 },
  { id: 'pool3', name: 'Cross/Recross', capMs: 25*60*1000 },
]);
function getCustomPoolKeys(){ return customPools.map(p=>p.id); }
const customPoolTimers = {
  pros: makePoolStopwatches('mt_custom_pros', getCustomPoolKeys()),
  def:  makePoolStopwatches('mt_custom_def',  getCustomPoolKeys())
};
function rebuildCustomTimersIfNeeded(){
  // Ensure stopwatches exist for all current pools
  const keys = new Set(getCustomPoolKeys());
  for (const side of ['pros','def']){
    for (const k of keys){
      if (!customPoolTimers[side][k]) customPoolTimers[side][k] = new Stopwatch(`mt_custom_${side}_${k}`);
    }
  }
}

/* =========================
   Objection tracking
========================= */
let objectionStats = loadJSON('mt_objection_stats', { count:0, ms:0, running:false, startedAt:0 });
function saveObjectionStats(){ saveJSON('mt_objection_stats', objectionStats); }
function objectionStart(){
  if (objectionStats.running) return;
  objectionStats.running = true;
  objectionStats.startedAt = nowMs();
  objectionStats.count += 1;
  saveObjectionStats();
}
function objectionStop(){
  if (!objectionStats.running) return;
  objectionStats.ms += (nowMs() - objectionStats.startedAt);
  objectionStats.running = false;
  objectionStats.startedAt = 0;
  saveObjectionStats();
}
function getObjectionMs(){
  return objectionStats.running ? (objectionStats.ms + (nowMs() - objectionStats.startedAt)) : objectionStats.ms;
}
let speechObjectionStartMs = 0;

/* =========================
   Logs
========================= */
let speechLog = loadJSON(STORE.speechLog, []);
let eventLog  = loadJSON(STORE.eventLog, []);

function logEvent(type, extra={}){
  const snap = {
    t: isoNow(),
    type,
    mode: state.mode,
    role: state.role || 'unselected',
    seg: (state.mode === 'free') ? 'free' : state.currentSegment,
    poolKey: state.currentPoolKey || '',
    ...extra,
    ms: {
      speech: speech.getElapsedMs(),
      prosTotal: prosTotal.getElapsedMs(),
      defTotal: defTotal.getElapsedMs(),
      round: round.getElapsedMs()
    }
  };
  eventLog.push(snap);
  saveJSON(STORE.eventLog, eventLog);
}

function maybeLogCurrentSpeech(reason){
  const ms = speech.getElapsedMs();
  if (ms < 1000) return false;

  const role = state.role || 'unselected';
  const objectionDuringSpeech = Math.max(0, getObjectionMs() - speechObjectionStartMs);

  const record = {
    at: isoNow(),
    reason,
    mode: state.mode,
    side: role,
    segment: (state.mode==='free' ? 'free' : state.currentSegment),
    poolKey: state.currentPoolKey || 'none',
    durationSec: Math.floor(ms/1000),
    objectionMs: objectionDuringSpeech,
    objectionCount: objectionStats.count
  };

  // Pool usage snapshot
  if (state.mode === 'amta' && (role==='pros'||role==='def') && state.currentPoolKey){
    const used = amtaPools[role][state.currentPoolKey].getElapsedMs();
    const cap = AMTA_CAPS_MS[state.currentPoolKey];
    record.poolUsedSec = Math.floor(used/1000);
    record.poolCapSec = Math.floor(cap/1000);
    record.poolOverSec = Math.floor(Math.max(0, used - cap)/1000);
  }
  if (state.mode === 'custom' && (role==='pros'||role==='def') && state.currentPoolKey){
    const used = customPoolTimers[role][state.currentPoolKey].getElapsedMs();
    const cap = (customPools.find(p=>p.id===state.currentPoolKey)?.capMs) || 0;
    record.poolUsedSec = Math.floor(used/1000);
    record.poolCapSec = Math.floor(cap/1000);
    record.poolOverSec = Math.floor(Math.max(0, used - cap)/1000);
  }

  speechLog.push(record);
  saveJSON(STORE.speechLog, speechLog);
  return true;
}

/* =========================
   Mode + segments + pools
========================= */
function segToPoolKey(mode, seg){
  if (mode === 'amta'){
    if (seg === 'direct') return 'direct';
    if (seg === 'cross') return 'cross';
    return 'openClose'; // opening/closing
  }
  if (mode === 'custom'){
    // map segment buttons to pool IDs by order
    const idx = ['opening','direct','cross','closing'].indexOf(seg);
    const pool = customPools[idx] || customPools[0];
    return pool?.id || null;
  }
  return null;
}

function setSegment(seg){
  state.currentSegment = seg;
  state.currentPoolKey = segToPoolKey(state.mode, seg);

  document.querySelectorAll('.segbtn').forEach(b=>{
    b.setAttribute('aria-pressed', (b.dataset.seg === seg) ? 'true' : 'false');
  });

  logEvent('segmentSelect', { segment: seg, poolKey: state.currentPoolKey });
  render();
}

function showSegmentsForMode(){
  const bar = document.getElementById('segmentBar');
  bar.style.display = (state.mode === 'amta' || state.mode === 'custom') ? 'flex' : 'none';

  // For custom mode: rename the segment buttons to pool names (first 4 pools)
  const btns = Array.from(bar.querySelectorAll('.segbtn'));
  if (state.mode === 'custom'){
    const labels = [
      customPools[0]?.name || 'Pool 1',
      customPools[1]?.name || 'Pool 2',
      customPools[2]?.name || 'Pool 3',
      customPools[3]?.name || 'Pool 4'
    ];
    btns.forEach((b,i)=>{ b.textContent = labels[i] || `Pool ${i+1}`; });
  } else {
    // AMTA defaults
    btns[0].textContent = 'Opening';
    btns[1].textContent = 'Direct';
    btns[2].textContent = 'Cross';
    btns[3].textContent = 'Closing';
  }
}

/* Pools UI */
function poolLabelAmta(k){
  if (k==='openClose') return 'Opening/Closing Pool';
  if (k==='direct') return 'Direct/Redirect Pool';
  if (k==='cross') return 'Cross/Recross Pool';
  return k;
}
function renderPoolsForSide(side){
  const host = document.getElementById(side === 'pros' ? 'prosPools' : 'defPools');
  host.innerHTML = '';

  if (state.mode === 'free'){
    host.style.display = 'none';
    return;
  }

  host.style.display = 'block';

  const pools = (state.mode === 'amta') ? amtaPools[side] : customPoolTimers[side];
  const keys = (state.mode === 'amta') ? ['openClose','direct','cross'] : getCustomPoolKeys();

  const wrap = document.createElement('div');
  wrap.style.display = 'grid';
  wrap.style.gap = '10px';

  for (const k of keys){
    const used = pools[k].getElapsedMs();
    const cap = (state.mode === 'amta')
      ? AMTA_CAPS_MS[k]
      : (customPools.find(p=>p.id===k)?.capMs || 0);
    const rem = cap - used;

    const item = document.createElement('div');
    item.style.border = '1px solid rgba(255,255,255,0.12)';
    item.style.background = 'rgba(255,255,255,0.05)';
    item.style.borderRadius = '16px';
    item.style.padding = '10px';

    const top = document.createElement('div');
    top.style.display = 'flex';
    top.style.justifyContent = 'space-between';
    top.style.alignItems = 'baseline';
    top.style.gap = '10px';

    const name = document.createElement('div');
    name.style.fontSize = '11px';
    name.style.fontWeight = '950';
    name.style.opacity = '.90';
    name.textContent = (state.mode === 'amta') ? poolLabelAmta(k) : (customPools.find(p=>p.id===k)?.name || 'Pool');

    const capEl = document.createElement('div');
    capEl.style.fontSize = '11px';
    capEl.style.fontWeight = '850';
    capEl.style.opacity = '.74';
    capEl.textContent = `Cap ${formatMsToMMSS(cap)}`;

    const time = document.createElement('div');
    time.style.marginTop = '6px';
    time.style.fontVariantNumeric = 'tabular-nums';
    time.style.letterSpacing = '.4px';
    time.style.fontWeight = '980';
    time.style.fontSize = '22px';
    time.textContent = formatMsToMMSS(used);

    const sub = document.createElement('div');
    sub.className = 'subline muted';
    sub.style.marginTop = '2px';

    // Under-timer label (always)
    if (rem <= 0){
      sub.textContent = formatOverageMs(rem);
      item.style.borderColor = 'rgba(146,40,51,0.50)';
      item.style.boxShadow = '0 0 14px rgba(146,40,51,0.12)';
    } else if (rem <= 60*1000){
      sub.textContent = `${formatMsToMMSS(rem)} left`;
      item.style.borderColor = 'rgba(201,162,58,0.50)';
      item.style.boxShadow = '0 0 14px rgba(201,162,58,0.11)';
    } else {
      sub.textContent = `${formatMsToMMSS(rem)} left`;
      sub.style.opacity = .70;
      sub.style.fontWeight = 800;
    }

    top.appendChild(name);
    top.appendChild(capEl);
    item.appendChild(top);
    item.appendChild(time);
    item.appendChild(sub);

    wrap.appendChild(item);
  }

  host.appendChild(wrap);
}

/* =========================
   Mutual exclusion (Pros/Def never run together)
========================= */
function startPros(){
  if (defTotal.running) defTotal.stop();
  prosTotal.start();
}
function startDef(){
  if (prosTotal.running) prosTotal.stop();
  defTotal.start();
}

function startPoolForRole(role){
  if (!state.currentPoolKey) return;
  if (state.mode === 'amta'){
    amtaPools[role][state.currentPoolKey].start();
  } else if (state.mode === 'custom'){
    rebuildCustomTimersIfNeeded();
    customPoolTimers[role][state.currentPoolKey].start();
  }
}
function stopAllPoolsForRole(role){
  if (state.mode === 'amta'){
    Object.values(amtaPools[role]).forEach(sw=>sw.stop());
  } else if (state.mode === 'custom'){
    Object.values(customPoolTimers[role]).forEach(sw=>sw.stop());
  }
}

/* =========================
   Speech start/pause with side sync
========================= */
function speechStartSynced(){
  speech.start();
  speechObjectionStartMs = getObjectionMs();
  logEvent('speechStart', { side: state.role || 'unselected' });

  if (state.role === 'pros'){
    startPros();
    startPoolForRole('pros');
  } else if (state.role === 'def'){
    startDef();
    startPoolForRole('def');
  }
}

function speechPauseSynced(){
  speech.stop();
  logEvent('speechPause', { side: state.role || 'unselected' });

  if (state.role === 'pros'){
    prosTotal.stop();
    stopAllPoolsForRole('pros');
  } else if (state.role === 'def'){
    defTotal.stop();
    stopAllPoolsForRole('def');
  }
}

/* =========================
   Objections mode (pause/resume last running set)
========================= */
let pausedSet = { speech:false, side:null, seg:null };

function objectionPause(){
  pausedSet = {
    speech: speech.running,
    side: (prosTotal.running ? 'pros' : (defTotal.running ? 'def' : null)),
    seg: (state.mode==='free' ? null : state.currentSegment)
  };

  objectionStart();
  logEvent('objectionPause', { pausedSet });

  // stop active timers
  if (speech.running) speech.stop();
  if (prosTotal.running) prosTotal.stop();
  if (defTotal.running) defTotal.stop();
  if (pausedSet.side === 'pros') stopAllPoolsForRole('pros');
  if (pausedSet.side === 'def') stopAllPoolsForRole('def');

  toast('Objection pause.');
}

function objectionResume(){
  objectionStop();
  logEvent('objectionResume', { resumeSet: pausedSet });

  if (pausedSet.seg && state.mode !== 'free') setSegment(pausedSet.seg);

  if (pausedSet.speech) speech.start();
  if (pausedSet.side === 'pros'){
    startPros();
    startPoolForRole('pros');
  }
  if (pausedSet.side === 'def'){
    startDef();
    startPoolForRole('def');
  }

  pausedSet = { speech:false, side:null, seg:null };
  toast('Resumed.');
}

/* =========================
   Round cap handling (3 hours)
========================= */
function roundStatus(){
  const used = round.getElapsedMs();
  const rem = ROUND_CAP_MS - used;
  if (rem <= 0) return { state:'over', label: `Cap ${formatMsToHHMMSS(ROUND_CAP_MS)} • ${formatOverageMs(rem)}` };
  if (rem <= ROUND_WARN_MS) return { state:'warn', label: `Cap ${formatMsToHHMMSS(ROUND_CAP_MS)} • ${formatMsToMMSS(rem)} left` };
  return { state:null, label: `Cap ${formatMsToHHMMSS(ROUND_CAP_MS)}` };
}

/* =========================
   Reset / end round
========================= */
function stopAllTimers(){
  speech.stop(); prosTotal.stop(); defTotal.stop(); round.stop();
  if (state.mode === 'amta'){ stopAllPoolsForRole('pros'); stopAllPoolsForRole('def'); }
  if (state.mode === 'custom'){ stopAllPoolsForRole('pros'); stopAllPoolsForRole('def'); }
}

function resetEverythingCore(showToast=true){
  stopAllTimers();

  speech.reset(); prosTotal.reset(); defTotal.reset(); round.reset();

  // pools
  Object.values(amtaPools.pros).forEach(sw=>sw.reset());
  Object.values(amtaPools.def).forEach(sw=>sw.reset());
  Object.values(customPoolTimers.pros).forEach(sw=>sw.reset());
  Object.values(customPoolTimers.def).forEach(sw=>sw.reset());

  // logs
  speechLog = []; eventLog = [];
  saveJSON(STORE.speechLog, speechLog);
  saveJSON(STORE.eventLog, eventLog);

  // objections
  objectionStats = { count:0, ms:0, running:false, startedAt:0 };
  saveObjectionStats();
  speechObjectionStartMs = 0;

  logEvent('resetEverything', {});
  renderLog();
  renderPoolsForSide('pros');
  renderPoolsForSide('def');
  render();

  if (showToast) toast('Reset.');
}

function endRound(){
  maybeLogCurrentSpeech('end_round');
  stopAllTimers();
  logEvent('endRound', {});
  renderLog();
  renderPoolsForSide('pros');
  renderPoolsForSide('def');
  render();
  toast('Round ended.');
}

/* =========================
   Exports (2 CSVs, one button)
========================= */
function filenameDate(){
  const d = new Date();
  return `${d.getFullYear()}-${pad2(d.getMonth()+1)}-${pad2(d.getDate())}`;
}

function buildTimesheetCSV(){
  const rows = [];
  const date = filenameDate();

  rows.push(['Mode','Date','Prosecution Total','Defense Total','Objections (count)','Objections (time)','Round Time']);
  rows.push([
    state.mode,
    date,
    formatMsToMMSS(prosTotal.getElapsedMs()),
    formatMsToMMSS(defTotal.getElapsedMs()),
    String(objectionStats.count),
    formatMsToMMSS(getObjectionMs()),
    formatMsToHHMMSS(round.getElapsedMs())
  ]);

  if (state.mode === 'amta'){
    rows.push([]);
    rows.push(['AMTA Pools','Cap','Pros Used','Pros Remaining/Over','Def Used','Def Remaining/Over']);
    for (const k of ['openClose','direct','cross']){
      const cap = AMTA_CAPS_MS[k];
      const pUsed = amtaPools.pros[k].getElapsedMs();
      const dUsed = amtaPools.def[k].getElapsedMs();
      const pRem = cap - pUsed;
      const dRem = cap - dUsed;
      rows.push([
        poolLabelAmta(k),
        formatMsToMMSS(cap),
        formatMsToMMSS(pUsed),
        (pRem >= 0 ? `${formatMsToMMSS(pRem)} left` : formatOverageMs(pRem)),
        formatMsToMMSS(dUsed),
        (dRem >= 0 ? `${formatMsToMMSS(dRem)} left` : formatOverageMs(dRem)),
      ]);
    }
    rows.push([]);
    rows.push(['Note','Rebuttal is part of the Prosecution Opening/Closing pool (14:00) and max 05:00.']);
  }

  if (state.mode === 'custom'){
    rows.push([]);
    rows.push(['Custom Pools','Cap','Pros Used','Pros Remaining/Over','Def Used','Def Remaining/Over']);
    rebuildCustomTimersIfNeeded();
    for (const p of customPools){
      const cap = p.capMs || 0;
      const pUsed = customPoolTimers.pros[p.id].getElapsedMs();
      const dUsed = customPoolTimers.def[p.id].getElapsedMs();
      const pRem = cap - pUsed;
      const dRem = cap - dUsed;
      rows.push([
        p.name,
        formatMsToMMSS(cap),
        formatMsToMMSS(pUsed),
        (pRem >= 0 ? `${formatMsToMMSS(pRem)} left` : formatOverageMs(pRem)),
        formatMsToMMSS(dUsed),
        (dRem >= 0 ? `${formatMsToMMSS(dRem)} left` : formatOverageMs(dRem)),
      ]);
    }
  }

  return rows.map(r=>r.map(csvEscape).join(',')).join('\n');
}

function buildOfficialRecordCSV(){
  const cols = ['timestamp','type','mode','role','segment','poolKey','speech_ms','prosTotal_ms','defTotal_ms','round_ms'];
  const lines = [cols.join(',')];
  for (const e of eventLog){
    const ms = e.ms || {};
    lines.push([
      e.t, e.type, e.mode, e.role, e.seg, e.poolKey || '',
      ms.speech ?? '', ms.prosTotal ?? '', ms.defTotal ?? '', ms.round ?? ''
    ].map(csvEscape).join(','));
  }
  return lines.join('\n');
}

async function exportRound(){
  const date = filenameDate();
  const timesheetName = `AMTA_Timesheet_${date}.csv`;
  const recordName = `Official_Round_Record_${date}.csv`;

  const a = buildTimesheetCSV();
  const b = buildOfficialRecordCSV();

  try{
    const shared = await shareFilesOrDownload([
      { name: timesheetName, content: a, mime:'text/csv' },
      { name: recordName, content: b, mime:'text/csv' }
    ]);
    toast(shared ? 'Exported via Share.' : 'Exported (downloaded).');
  }catch{
    downloadTextFile(timesheetName, a, 'text/csv');
    downloadTextFile(recordName, b, 'text/csv');
    toast('Exported (downloaded).');
  }
}

/* =========================
   Log UI
========================= */
const logList = document.getElementById('logList');
const logHint = document.getElementById('logHint');

function renderLog(){
  logList.innerHTML = '';
  if (!speechLog.length){
    logHint.textContent = 'No speeches saved yet';
    return;
  }
  logHint.textContent = `${speechLog.length} speech${speechLog.length===1?'':'es'} saved`;

  speechLog.forEach((item, idx)=>{
    const li = document.createElement('li');
    li.className = 'logitem';

    const left = document.createElement('div');
    const side = item.side === 'pros' ? 'Prosecution' : (item.side === 'def' ? 'Defense' : 'Unselected');
    const seg = item.segment;
    left.innerHTML = `<div class="meta">Speech ${idx+1} • ${side} • ${seg}</div>`;

    const right = document.createElement('div');
    right.textContent = formatMsToMMSS(item.durationSec*1000);

    li.appendChild(left);
    li.appendChild(right);
    logList.appendChild(li);
  });
}

/* =========================
   Rendering
========================= */
const el = {
  speechTime: document.getElementById('speechTime'),
  prosTime: document.getElementById('prosTime'),
  defTime: document.getElementById('defTime'),
  roundTime: document.getElementById('roundTime'),

  speechHint: document.getElementById('speechHint'),
  prosHint: document.getElementById('prosHint'),
  defHint: document.getElementById('defHint'),
  roundHint: document.getElementById('roundHint'),

  speechSub: document.getElementById('speechSub'),
  prosSub: document.getElementById('prosSub'),
  defSub: document.getElementById('defSub'),
  roundSub: document.getElementById('roundSub'),

  runningIndicator: document.getElementById('runningIndicator'),

  cardSpeech: document.getElementById('cardSpeech'),
  cardPros: document.getElementById('cardPros'),
  cardDef: document.getElementById('cardDef'),
  cardRound: document.getElementById('cardRound'),
};

function setCardState(card, state){
  card.classList.remove('state-running','state-warn','state-over');
  if (state) card.classList.add(state);
}

function computePoolStateForRunningSide(side){
  if (!(state.mode === 'amta' || state.mode === 'custom')) return null;
  if (!state.currentPoolKey) return 'state-running';

  const pools = (state.mode === 'amta') ? amtaPools[side] : customPoolTimers[side];
  const cap = (state.mode === 'amta')
    ? AMTA_CAPS_MS[state.currentPoolKey]
    : (customPools.find(p=>p.id===state.currentPoolKey)?.capMs || 0);
  const used = pools[state.currentPoolKey]?.getElapsedMs?.() ?? 0;
  const rem = cap - used;

  if (rem <= 0) return 'state-over';
  if (rem <= 60*1000) return 'state-warn';
  return 'state-running';
}

let lastPoolWarnBeepAt = 0;

function render(){
  el.speechTime.textContent = formatMsToMMSS(speech.getElapsedMs());
  el.prosTime.textContent   = formatMsToMMSS(prosTotal.getElapsedMs());
  el.defTime.textContent    = formatMsToMMSS(defTotal.getElapsedMs());
  el.roundTime.textContent  = formatMsToHHMMSS(round.getElapsedMs());

  el.speechHint.textContent = speech.running ? 'Running' : 'Stopped';
  el.prosHint.textContent   = prosTotal.running ? 'Running' : 'Stopped';
  el.defHint.textContent    = defTotal.running ? 'Running' : 'Stopped';
  el.roundHint.textContent  = round.running ? 'Running' : 'Stopped';

  // speech subline
  if (state.mode === 'amta'){
    el.speechSub.textContent = `AMTA • ${state.currentSegment}`;
  } else if (state.mode === 'custom'){
    const poolName = customPools.find(p=>p.id===state.currentPoolKey)?.name || 'Custom';
    el.speechSub.textContent = `Custom • ${poolName}`;
  } else {
    el.speechSub.textContent = 'Ready';
  }

  // side sublines
  el.prosSub.textContent = (state.mode==='free') ? 'Ready' : 'Pools below';
  el.defSub.textContent  = (state.mode==='free') ? 'Ready' : 'Pools below';

  // round cap label
  const rs = roundStatus();
  el.roundSub.textContent = rs.label;
  setCardState(el.cardRound, rs.state ? (rs.state==='warn' ? 'state-warn' : 'state-over') : (round.running ? 'state-running' : null));

  // running indicator
  const running = [];
  if (speech.running) running.push('Speech');
  if (prosTotal.running) running.push('Pros');
  if (defTotal.running) running.push('Def');
  if (round.running) running.push('Round');
  if (objectionStats.running) running.push('Objection');
  el.runningIndicator.textContent = running.length ? `Running: ${running.join(', ')}` : 'All stopped';

  // card states
  setCardState(el.cardSpeech, speech.running ? 'state-running' : null);

  if (prosTotal.running){
    setCardState(el.cardPros, computePoolStateForRunningSide('pros'));
  } else {
    setCardState(el.cardPros, null);
  }

  if (defTotal.running){
    setCardState(el.cardDef, computePoolStateForRunningSide('def'));
  } else {
    setCardState(el.cardDef, null);
  }

  // Beep for pool warning/over (rate-limited)
  if (state.sound && (prosTotal.running || defTotal.running) && (state.mode==='amta' || state.mode==='custom')){
    const side = prosTotal.running ? 'pros' : 'def';
    const pools = (state.mode==='amta') ? amtaPools[side] : customPoolTimers[side];
    const cap = (state.mode==='amta')
      ? AMTA_CAPS_MS[state.currentPoolKey]
      : (customPools.find(p=>p.id===state.currentPoolKey)?.capMs || 0);
    const used = pools[state.currentPoolKey]?.getElapsedMs?.() ?? 0;
    const rem = cap - used;

    const now = nowMs();
    if (rem <= 60*1000 && rem > 0 && now - lastPoolWarnBeepAt > 2500){
      beep('warn'); lastPoolWarnBeepAt = now;
    }
    if (rem <= 0 && now - lastPoolWarnBeepAt > 2500){
      beep('over'); lastPoolWarnBeepAt = now;
    }
  }
}

setInterval(render, 200);
setInterval(()=>{ if (state.mode !== 'free'){ renderPoolsForSide('pros'); renderPoolsForSide('def'); } }, 900);

/* =========================
   Options sheet (stable + iOS-safe)
========================= */
const optionsBtn = document.getElementById('optionsBtn');
const sheet = document.getElementById('sheet');
const backdrop = document.getElementById('backdrop');
const closeSheetBtn = document.getElementById('closeSheetBtn');
let lastFocus = null;

function openSheet(){
  lastFocus = document.activeElement;
  sheet.classList.add('open');
  backdrop.classList.add('open');
  sheet.setAttribute('aria-hidden','false');
  backdrop.setAttribute('aria-hidden','false');
  optionsBtn.setAttribute('aria-expanded','true');
  document.body.style.overflow = 'hidden';
  setTimeout(()=>document.getElementById('modeSelect').focus(), 40);
}
function closeSheet(){
  sheet.classList.remove('open');
  backdrop.classList.remove('open');
  sheet.setAttribute('aria-hidden','true');
  backdrop.setAttribute('aria-hidden','true');
  optionsBtn.setAttribute('aria-expanded','false');
  document.body.style.overflow = document.body.classList.contains('game-lock') ? 'hidden' : '';
  if (lastFocus && lastFocus.focus) setTimeout(()=>lastFocus.focus(), 0);
}

optionsBtn.addEventListener('click', ()=> sheet.classList.contains('open') ? closeSheet() : openSheet());
closeSheetBtn.addEventListener('click', closeSheet);
backdrop.addEventListener('click', closeSheet);

document.addEventListener('keydown', (e)=>{
  if (e.key === 'Escape' && sheet.classList.contains('open')) closeSheet();

  // basic focus trap
  if (e.key === 'Tab' && sheet.classList.contains('open')){
    const focusables = sheet.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const list = Array.from(focusables).filter(x=>!x.disabled);
    if (!list.length) return;
    const first = list[0];
    const last = list[list.length-1];
    if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
    else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
  }
});

/* =========================
   Mode switching (freeze-proof)
========================= */
const confirmModal = document.getElementById('confirmModal');
let pendingMode = null;
let modeSwitchInProgress = false;

function anyTimerRunning(){
  return speech.running || prosTotal.running || defTotal.running || round.running || objectionStats.running;
}
function showConfirmSwitch(newMode){
  pendingMode = newMode;
  confirmModal.classList.add('open');
  confirmModal.setAttribute('aria-hidden','false');
  logEvent('modeSwitchPrompt', { to:newMode });
}
function closeConfirm(){
  confirmModal.classList.remove('open');
  confirmModal.setAttribute('aria-hidden','true');
  pendingMode = null;
  modeSwitchInProgress = false;
}

function applyMode(newMode, resetRound){
  const old = state.mode;

  if (resetRound) resetEverythingCore(false);

  setMode(newMode);
  showSegmentsForMode();

  // Ensure pool keys update
  state.currentPoolKey = segToPoolKey(state.mode, state.currentSegment);

  // Pools visibility
  document.getElementById('customGroup').style.display = (state.mode === 'custom') ? 'block' : 'none';

  logEvent(resetRound ? 'modeChangeReset' : 'modeChange', { from: old, to: newMode });

  // refresh UI
  renderPoolsForSide('pros');
  renderPoolsForSide('def');
  render();
  toast(`Mode: ${newMode.toUpperCase()}`);
}

const modeSelect = document.getElementById('modeSelect');
modeSelect.addEventListener('change', ()=>{
  if (modeSwitchInProgress) return;
  const desired = modeSelect.value;
  if (desired === state.mode) return;

  // Immediately revert selection to current mode for stability
  modeSwitchInProgress = true;
  modeSelect.value = state.mode;

  if (anyTimerRunning() || speechLog.length){
    showConfirmSwitch(desired);
  } else {
    applyMode(desired, false);
    modeSwitchInProgress = false;
  }
});

document.getElementById('confirmResetSwitch').addEventListener('click', ()=>{
  if (!pendingMode) return closeConfirm();
  const m = pendingMode;
  closeConfirm();
  applyMode(m, true);
});
document.getElementById('confirmLogSwitch').addEventListener('click', ()=>{
  if (!pendingMode) return closeConfirm();
  const m = pendingMode;
  closeConfirm();
  applyMode(m, false);
});
document.getElementById('confirmCancel').addEventListener('click', ()=>{
  closeConfirm();
});

/* =========================
   Toggles + persistence
========================= */
function applyMobileMode(enabled){
  document.body.classList.toggle('mobile-mode', !!enabled);
  localStorage.setItem(STORE.mobile, enabled ? '1' : '0');
  document.getElementById('mobileToggle').checked = !!enabled;
}
function setGameLock(enabled){
  document.body.classList.toggle('game-lock', !!enabled);
  localStorage.setItem(STORE.lock, enabled ? '1' : '0');
  document.getElementById('gameLockToggle').checked = !!enabled;
  if (enabled){
    closeSheet();
    document.body.style.overflow = 'hidden';
    toast('Game Day Lock on.');
  } else {
    document.body.style.overflow = '';
    toast('Game Day Lock off.');
  }
}

function applyA11y(){
  const a11y = loadJSON(STORE.a11y, { hc:false, ln:false, rt:false });
  document.body.classList.toggle('high-contrast', !!a11y.hc);
  document.body.classList.toggle('large-numbers', !!a11y.ln);
  document.body.classList.toggle('reduce-transparency', !!a11y.rt);

  document.getElementById('hcToggle').checked = !!a11y.hc;
  document.getElementById('lnToggle').checked = !!a11y.ln;
  document.getElementById('rtToggle').checked = !!a11y.rt;
}
function setA11yPatch(patch){
  const a11y = loadJSON(STORE.a11y, { hc:false, ln:false, rt:false });
  saveJSON(STORE.a11y, { ...a11y, ...patch });
  applyA11y();
}

document.getElementById('mobileToggle').addEventListener('change', e=>applyMobileMode(e.target.checked));
document.getElementById('gameLockToggle').addEventListener('change', e=>setGameLock(e.target.checked));
document.getElementById('hcToggle').addEventListener('change', e=>setA11yPatch({hc:e.target.checked}));
document.getElementById('lnToggle').addEventListener('change', e=>setA11yPatch({ln:e.target.checked}));
document.getElementById('rtToggle').addEventListener('change', e=>setA11yPatch({rt:e.target.checked}));

document.getElementById('soundToggle').addEventListener('change', e=>{
  state.sound = !!e.target.checked;
  localStorage.setItem(STORE.sound, state.sound ? '1' : '0');
  toast(state.sound ? 'Sound cues on.' : 'Sound cues off.');
});

document.getElementById('rolePros').addEventListener('change', ()=>{ if (document.getElementById('rolePros').checked){ setRole('pros'); logEvent('roleSet',{side:'pros'}); }});
document.getElementById('roleDef').addEventListener('change', ()=>{ if (document.getElementById('roleDef').checked){ setRole('def'); logEvent('roleSet',{side:'def'}); }});

document.getElementById('unlockBtn').addEventListener('click', ()=>{
  setGameLock(false);
  openSheet();
});

/* =========================
   Wake Lock (offline-safe)
========================= */
let wakeLock = null;
async function requestWakeLock(){
  try{
    if (!('wakeLock' in navigator)) return false;
    wakeLock = await navigator.wakeLock.request('screen');
    return true;
  }catch{ return false; }
}
async function releaseWakeLock(){
  try{ if (wakeLock) await wakeLock.release(); }catch{}
  wakeLock = null;
}
const wakeToggle = document.getElementById('wakeToggle');
wakeToggle.addEventListener('change', async ()=>{
  if (wakeToggle.checked){
    const ok = await requestWakeLock();
    if (!ok) wakeToggle.checked = false;
  } else {
    await releaseWakeLock();
  }
  saveJSON(STORE.wake, { enabled: wakeToggle.checked });
});
document.addEventListener('visibilitychange', async ()=>{
  if (document.visibilityState === 'visible' && wakeToggle.checked){
    await requestWakeLock();
  }
});

/* =========================
   Custom pools editor
========================= */
const poolListEl = document.getElementById('poolList');

function renderCustomPoolEditor(){
  poolListEl.innerHTML = '';
  customPools.forEach((p, idx)=>{
    const item = document.createElement('div');
    item.className = 'poolitem';

    const row = document.createElement('div');
    row.className = 'poolrow';

    const nameInput = document.createElement('input');
    nameInput.value = p.name;
    nameInput.placeholder = 'Pool name';
    nameInput.setAttribute('aria-label', `Pool ${idx+1} name`);

    const capInput = document.createElement('input');
    capInput.value = formatMsToMMSS(p.capMs || 0);
    capInput.placeholder = 'mm:ss';
    capInput.setAttribute('inputmode','numeric');
    capInput.setAttribute('aria-label', `Pool ${idx+1} cap (mm:ss)`);

    const delBtn = document.createElement('button');
    delBtn.className = 'danger';
    delBtn.textContent = 'Delete';
    delBtn.disabled = customPools.length <= 1;

    nameInput.addEventListener('change', ()=>{
      p.name = nameInput.value.trim() || p.name;
      saveJSON(STORE.customPools, customPools);
      showSegmentsForMode();
      renderPoolsForSide('pros'); renderPoolsForSide('def');
    });

    capInput.addEventListener('change', ()=>{
      const ms = parseCapMMSS(capInput.value);
      if (ms == null){
        capInput.value = formatMsToMMSS(p.capMs || 0);
        toast('Cap format: mm:ss');
        return;
      }
      p.capMs = ms;
      saveJSON(STORE.customPools, customPools);
      renderPoolsForSide('pros'); renderPoolsForSide('def');
      toast('Cap updated.');
    });

    delBtn.addEventListener('click', ()=>{
      customPools = customPools.filter(x=>x.id !== p.id);
      saveJSON(STORE.customPools, customPools);
      rebuildCustomTimersIfNeeded();
      renderCustomPoolEditor();
      showSegmentsForMode();
      state.currentPoolKey = segToPoolKey(state.mode, state.currentSegment);
      renderPoolsForSide('pros'); renderPoolsForSide('def');
    });

    row.appendChild(nameInput);
    row.appendChild(capInput);
    row.appendChild(delBtn);
    item.appendChild(row);
    poolListEl.appendChild(item);
  });
}

document.getElementById('addPoolBtn').addEventListener('click', ()=>{
  const id = 'pool' + Math.random().toString(16).slice(2,8);
  customPools.push({ id, name: `Pool ${customPools.length+1}`, capMs: 10*60*1000 });
  saveJSON(STORE.customPools, customPools);
  rebuildCustomTimersIfNeeded();
  renderCustomPoolEditor();
  showSegmentsForMode();
  renderPoolsForSide('pros'); renderPoolsForSide('def');
  toast('Pool added.');
});

document.getElementById('resetPoolsBtn').addEventListener('click', ()=>{
  if (!confirm('Reset custom pools to defaults?')) return;
  customPools = [
    { id: 'pool1', name: 'Opening/Closing', capMs: 14*60*1000 },
    { id: 'pool2', name: 'Direct/Redirect', capMs: 25*60*1000 },
    { id: 'pool3', name: 'Cross/Recross', capMs: 25*60*1000 },
  ];
  saveJSON(STORE.customPools, customPools);
  rebuildCustomTimersIfNeeded();
  renderCustomPoolEditor();
  showSegmentsForMode();
  toast('Custom pools reset.');
});

/* =========================
   Buttons wiring
========================= */
// segment buttons
document.querySelectorAll('.segbtn').forEach(btn=>{
  btn.addEventListener('click', ()=> setSegment(btn.dataset.seg));
});

// speech
document.getElementById('speechStart').addEventListener('click', speechStartSynced);
document.getElementById('speechPause').addEventListener('click', speechPauseSynced);
document.getElementById('speechReset').addEventListener('click', ()=>{
  logEvent('speechReset', {});
  const logged = maybeLogCurrentSpeech('speech_reset');
  speech.reset();
  if (logged) toast('Speech saved.');
  renderLog();
  render();
});

// sides manual
document.getElementById('prosStart').addEventListener('click', ()=>{ logEvent('prosStartManual',{}); startPros(); });
document.getElementById('prosPause').addEventListener('click', ()=>{ logEvent('prosPauseManual',{}); prosTotal.stop(); stopAllPoolsForRole('pros'); });
document.getElementById('prosReset').addEventListener('click', ()=>{ logEvent('prosResetManual',{}); prosTotal.reset(); stopAllPoolsForRole('pros'); renderPoolsForSide('pros'); });

document.getElementById('defStart').addEventListener('click', ()=>{ logEvent('defStartManual',{}); startDef(); });
document.getElementById('defPause').addEventListener('click', ()=>{ logEvent('defPauseManual',{}); defTotal.stop(); stopAllPoolsForRole('def'); });
document.getElementById('defReset').addEventListener('click', ()=>{ logEvent('defResetManual',{}); defTotal.reset(); stopAllPoolsForRole('def'); renderPoolsForSide('def'); });

// round
document.getElementById('roundStart').addEventListener('click', ()=>{ logEvent('roundStart',{}); round.start(); });
document.getElementById('roundPause').addEventListener('click', ()=>{ logEvent('roundPause',{}); round.stop(); });
document.getElementById('roundReset').addEventListener('click', ()=>{ logEvent('roundReset',{}); round.reset(); });

// objections
document.getElementById('objectionPause').addEventListener('click', objectionPause);
document.getElementById('objectionResume').addEventListener('click', objectionResume);

// end/export/reset
document.getElementById('endRoundBtn').addEventListener('click', endRound);
document.getElementById('exportBtn').addEventListener('click', exportRound);

document.getElementById('endRoundFromMenu').addEventListener('click', ()=>{ closeSheet(); endRound(); });
document.getElementById('exportFromMenu').addEventListener('click', async ()=>{ closeSheet(); await exportRound(); });
document.getElementById('resetEverythingBtn').addEventListener('click', ()=>{ closeSheet(); if (confirm('Reset everything? This clears timers and logs.')) resetEverythingCore(true); });

/* =========================
   Auto-hide header on scroll (hide fast)
========================= */
(function autoHideHeader(){
  const header = document.getElementById('topHeader');
  if (!header) return;
  let lastY = window.scrollY || 0;
  let ticking = false;

  function onScroll(){
    const y = window.scrollY || 0;
    const dy = y - lastY;

    if (y <= 8){
      header.classList.remove('is-hidden');
      lastY = y; ticking = false; return;
    }
    if (dy > 2) header.classList.add('is-hidden');
    if (dy < -2) header.classList.remove('is-hidden');

    lastY = y;
    ticking = false;
  }

  window.addEventListener('scroll', ()=>{
    if (ticking) return;
    ticking = true;
    requestAnimationFrame(onScroll);
  }, { passive:true });
})();

/* =========================
   Init
========================= */
(function init(){
  // state
  state.mode = getMode();
  state.role = getRole();
  state.sound = (localStorage.getItem(STORE.sound) === '1');

  // UI set
  setMode(state.mode);
  if (state.role) setRole(state.role);

  // toggles restore
  applyMobileMode(localStorage.getItem(STORE.mobile) === '1');
  setGameLock(localStorage.getItem(STORE.lock) === '1');

  applyA11y();
  document.getElementById('soundToggle').checked = !!state.sound;
  document.getElementById('customGroup').style.display = (state.mode === 'custom') ? 'block' : 'none';

  // wake
  const w = loadJSON(STORE.wake, { enabled:false });
  if (w.enabled){
    wakeToggle.checked = true;
    requestWakeLock().then(ok => { if (!ok) wakeToggle.checked = false; });
  }

  // custom pools editor
  rebuildCustomTimersIfNeeded();
  renderCustomPoolEditor();

  // segments
  showSegmentsForMode();
  setSegment('opening');

  // round starts at 0:00 and never auto-start
  round.reset();

  // logs
  renderLog();

  // pools
  renderPoolsForSide('pros');
  renderPoolsForSide('def');

  // first render
  render();
  logEvent('appLoad', {});
})();

/* =========================
   Offline / airplane-mode: service worker
========================= */
if ('serviceWorker' in navigator){
  window.addEventListener('load', ()=>{
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  });
}
</script>
</body>
</html>
