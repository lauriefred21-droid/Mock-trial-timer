<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#0f1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <title>Mock Trial Timer</title>

  <link rel="manifest" href="manifest.webmanifest" />

  <style>
    :root { color-scheme: dark; }
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(130,87,229,0.35), transparent 60%),
        radial-gradient(900px 700px at 110% 10%, rgba(44,203,161,0.25), transparent 55%),
        radial-gradient(900px 700px at 50% 120%, rgba(255,181,72,0.18), transparent 55%),
        #070814;
      color: #f3f4f6;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    header {
      padding: 14px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      border-bottom: 1px solid rgba(255,255,255,0.08);
      position: sticky;
      top: 0;
      background: rgba(7,8,20,0.6);
      backdrop-filter: blur(12px);
      z-index: 10;
    }
    header h1 {
      font-size: 16px;
      margin: 0;
      font-weight: 900;
      letter-spacing: 0.2px;
    }
    header .subtitle {
      font-size: 12px;
      opacity: 0.7;
      margin-top: 2px;
    }

    .top-controls { display: flex; gap: 10px; align-items: center; }
    .chip {
      border: 1px solid rgba(255,255,255,0.14);
      background: rgba(255,255,255,0.06);
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 13px;
      font-weight: 800;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      user-select: none;
    }
    .chip input { transform: scale(1.12); }

    .wrap { padding: 16px; max-width: 900px; margin: 0 auto; }

    .grid { display: grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) {
      .grid { grid-template-columns: 1fr 1fr; }
      .span-2 { grid-column: 1 / span 2; }
    }

    .card {
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(255,255,255,0.06);
      border-radius: 18px;
      padding: 14px;
      box-shadow: 0 12px 30px rgba(0,0,0,0.35);
      overflow: hidden;
      position: relative;
    }
    .card::before {
      content: "";
      position: absolute;
      inset: 0;
      background: radial-gradient(600px 240px at 20% 0%, rgba(255,255,255,0.12), transparent 60%);
      pointer-events: none;
    }

    .label {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
      position: relative;
    }
    .name {
      font-size: 13px;
      opacity: 0.92;
      font-weight: 900;
      letter-spacing: 0.25px;
      text-transform: uppercase;
    }
    .hint {
      font-size: 12px;
      opacity: 0.7;
      font-weight: 700;
    }

    .time {
      font-variant-numeric: tabular-nums;
      letter-spacing: 0.6px;
      user-select: none;
      margin: 8px 0 12px;
      position: relative;
      font-weight: 950;
    }
    .time.big { font-size: 72px; line-height: 1.0; }
    .time.med { font-size: 54px; line-height: 1.03; }
    @media (max-width: 420px) {
      .time.big { font-size: 58px; }
      .time.med { font-size: 44px; }
    }

    .controls { display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; position: relative; }
    @media (max-width: 520px) { .controls { grid-template-columns: 1fr 1fr auto; } }

    button {
      border: 1px solid rgba(255,255,255,0.16);
      background: rgba(255,255,255,0.08);
      color: #f3f4f6;
      padding: 12px 14px;
      border-radius: 14px;
      font-size: 14px;
      font-weight: 900;
      cursor: pointer;
      touch-action: manipulation;
      user-select: none;
      min-height: 46px;
    }
    button:active { transform: scale(0.99); }
    button.primary {
      background: rgba(255,255,255,0.92);
      color: #0b1020;
      border-color: rgba(255,255,255,0.92);
    }
    button.pause {
      background: rgba(255, 70, 70, 0.18);
      border-color: rgba(255, 70, 70, 0.35);
      font-weight: 950;
    }
    button.ghost { background: transparent; }
    button.reset {
      padding: 10px 12px;
      min-height: 40px;
      font-size: 12px;
      font-weight: 850;
      opacity: 0.9;
    }

    /* Objections mode dock */
    .dock {
      margin-top: 12px;
      padding: 12px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(7,8,20,0.55);
      backdrop-filter: blur(14px);
      box-shadow: 0 18px 40px rgba(0,0,0,0.45);
      display: grid;
      gap: 10px;
      position: relative;
    }
    .dock-top {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }
    .dock-title { font-weight: 950; letter-spacing: 0.3px; }
    .dock-sub { font-size: 12px; opacity: 0.75; font-weight: 700; }
    .dock-buttons { display: grid; grid-template-columns: 1fr; gap: 10px; }
    button.objection {
      background: rgba(255, 70, 70, 0.92);
      border-color: rgba(255, 70, 70, 0.92);
      color: #0b1020;
      font-weight: 980;
      letter-spacing: 0.4px;
      min-height: 54px;
      font-size: 16px;
    }
    button.resume {
      background: rgba(44,203,161,0.92);
      border-color: rgba(44,203,161,0.92);
      color: #071018;
      font-weight: 980;
      min-height: 54px;
      font-size: 16px;
    }

    .small {
      font-size: 12px;
      opacity: 0.78;
      line-height: 1.35;
      position: relative;
    }
  </style>
</head>

<body>
<header>
  <div>
    <h1>Mock Trial Timer</h1>
    <div class="subtitle">Objection-proof timing. Big digits. Fast control.</div>
  </div>

  <div class="top-controls">
    <label class="chip" title="Keep screen awake (if supported)">
      <input id="wakeToggle" type="checkbox" />
      Wake Lock
    </label>
    <button class="ghost" id="resetAllBtn" title="Reset speech + pros + def (not round)">Reset (Speech/Side)</button>
  </div>
</header>

<div class="wrap">

  <div class="grid">

    <!-- Current Speech -->
    <section class="card span-2" aria-label="Current Speech">
      <div class="label">
        <div class="name">Current Speech</div>
        <div class="hint" id="speechHint">Stopped</div>
      </div>
      <div class="time big" id="speechTime">00:00.0</div>
      <div class="controls">
        <button class="primary" id="speechStart">Start</button>
        <button class="pause" id="speechPause">Pause</button>
        <button class="reset" id="speechReset">Reset</button>
      </div>
      <div class="small">Objections Mode pauses/resumes the timers that were actually running (round time never pauses).</div>
    </section>

    <!-- Prosecution -->
    <section class="card" aria-label="Prosecution Total Time">
      <div class="label">
        <div class="name">Prosecution Total Time</div>
        <div class="hint" id="prosHint">Stopped</div>
      </div>
      <div class="time med" id="prosTime">00:00.0</div>
      <div class="controls">
        <button class="primary" id="prosStart">Start</button>
        <button class="pause" id="prosPause">Pause</button>
        <button class="reset" id="prosReset">Reset</button>
      </div>
    </section>

    <!-- Defense -->
    <section class="card" aria-label="Defense Total Time">
      <div class="label">
        <div class="name">Defense Total Time</div>
        <div class="hint" id="defHint">Stopped</div>
      </div>
      <div class="time med" id="defTime">00:00.0</div>
      <div class="controls">
        <button class="primary" id="defStart">Start</button>
        <button class="pause" id="defPause">Pause</button>
        <button class="reset" id="defReset">Reset</button>
      </div>
    </section>

    <!-- Objections Mode -->
    <section class="dock span-2" aria-label="Objections Mode">
      <div class="dock-top">
        <div>
          <div class="dock-title">Objections Mode</div>
          <div class="dock-sub">Pauses current timers. Resumes only the last running set.</div>
        </div>
        <div class="dock-sub" id="runningIndicator">All stopped</div>
      </div>

      <div class="dock-buttons">
        <button class="objection" id="objectionPause">Pause current speeches</button>
        <button class="resume" id="objectionResume">Resume current speeches</button>
      </div>

      <div class="small">
        Rule: Prosecution and Defense totals can’t run at the same time. Starting one automatically pauses the other.
      </div>
    </section>

    <!-- Total Round Time (BOTTOM, unaffected by objections) -->
    <section class="card span-2" aria-label="Total Round Time">
      <div class="label">
        <div class="name">Total Round Time</div>
        <div class="hint" id="roundHint">Stopped</div>
      </div>
      <div class="time med" id="roundTime">00:00.0</div>
      <div class="controls" style="grid-template-columns: 1fr auto;">
        <button class="primary" id="roundStart">Start</button>
        <button class="reset" id="roundReset">Reset</button>
      </div>
      <div class="small">This timer is never paused by Objections Mode. It’s your “real-world” round clock.</div>
    </section>

  </div>
</div>

<script>
  // --- Utility: format time ---
  function formatMs(ms) {
    ms = Math.max(0, ms);
    const totalTenths = Math.floor(ms / 100);
    const tenths = totalTenths % 10;
    const totalSeconds = Math.floor(totalTenths / 10);
    const seconds = totalSeconds % 60;
    const minutes = Math.floor(totalSeconds / 60);
    const mm = String(minutes).padStart(2, '0');
    const ss = String(seconds).padStart(2, '0');
    return `${mm}:${ss}.${tenths}`;
  }

  // --- Stopwatch (battery-friendly: ticks only while running) ---
  class Stopwatch {
    constructor(key, onUpdate) {
      this.key = key;
      this.onUpdate = onUpdate;
      this.elapsed = 0;
      this.running = false;
      this._t0 = 0;
      this._timer = null;

      this.load();
      this.onUpdate(this.getElapsed());
    }

    getElapsed() {
      if (!this.running) return this.elapsed;
      return this.elapsed + (performance.now() - this._t0);
    }

    start() {
      if (this.running) return;
      this.running = true;
      this._t0 = performance.now();
      this._timer = setInterval(() => {
        this.onUpdate(this.getElapsed());
        this.save();
      }, 200);
      this.save();
    }

    stop() {
      if (!this.running) return;
      this.elapsed = this.getElapsed();
      this.running = false;
      clearInterval(this._timer);
      this._timer = null;
      this.onUpdate(this.elapsed);
      this.save();
    }

    reset() {
      this.elapsed = 0;
      if (this.running) this._t0 = performance.now();
      this.onUpdate(this.getElapsed());
      this.save();
    }

    save() {
      localStorage.setItem(this.key, JSON.stringify({
        elapsed: this.elapsed,
        running: this.running
      }));
    }

    load() {
      try {
        const raw = localStorage.getItem(this.key);
        if (!raw) return;
        const payload = JSON.parse(raw);
        this.elapsed = payload.elapsed || 0;
        this.running = !!payload.running;
        if (this.running) {
          this._t0 = performance.now();
          this._timer = setInterval(() => {
            this.onUpdate(this.getElapsed());
            this.save();
          }, 200);
        }
      } catch {}
    }
  }

  // --- Wake Lock (optional) ---
  let wakeLock = null;
  async function requestWakeLock() {
    try {
      if (!('wakeLock' in navigator)) return false;
      wakeLock = await navigator.wakeLock.request('screen');
      return true;
    } catch { return false; }
  }
  async function releaseWakeLock() {
    try { if (wakeLock) await wakeLock.release(); } catch {}
    wakeLock = null;
  }

  // --- UI elements ---
  const speechTimeEl = document.getElementById('speechTime');
  const prosTimeEl = document.getElementById('prosTime');
  const defTimeEl = document.getElementById('defTime');
  const roundTimeEl = document.getElementById('roundTime');

  const speechHint = document.getElementById('speechHint');
  const prosHint = document.getElementById('prosHint');
  const defHint = document.getElementById('defHint');
  const roundHint = document.getElementById('roundHint');
  const runningIndicator = document.getElementById('runningIndicator');

  // --- Timers ---
  const speech = new Stopwatch('mt_speech', (ms) => {
    speechTimeEl.textContent = formatMs(ms);
    speechHint.textContent = speech.running ? 'Running' : 'Stopped';
    updateIndicator();
  });

  const pros = new Stopwatch('mt_pros', (ms) => {
    prosTimeEl.textContent = formatMs(ms);
    prosHint.textContent = pros.running ? 'Running' : 'Stopped';
    updateIndicator();
  });

  const def = new Stopwatch('mt_def', (ms) => {
    defTimeEl.textContent = formatMs(ms);
    defHint.textContent = def.running ? 'Running' : 'Stopped';
    updateIndicator();
  });

  const round = new Stopwatch('mt_round', (ms) => {
    roundTimeEl.textContent = formatMs(ms);
    roundHint.textContent = round.running ? 'Running' : 'Stopped';
    updateIndicator();
  });

  // --- Mutual exclusion: pros/def never run together ---
  function startPros() {
    if (def.running) def.stop();
    pros.start();
  }
  function startDef() {
    if (pros.running) pros.stop();
    def.start();
  }

  // --- Buttons: speech ---
  document.getElementById('speechStart').addEventListener('click', () => speech.start());
  document.getElementById('speechPause').addEventListener('click', () => speech.stop());
  document.getElementById('speechReset').addEventListener('click', () => speech.reset());

  // --- Buttons: pros ---
  document.getElementById('prosStart').addEventListener('click', startPros);
  document.getElementById('prosPause').addEventListener('click', () => pros.stop());
  document.getElementById('prosReset').addEventListener('click', () => pros.reset());

  // --- Buttons: def ---
  document.getElementById('defStart').addEventListener('click', startDef);
  document.getElementById('defPause').addEventListener('click', () => def.stop());
  document.getElementById('defReset').addEventListener('click', () => def.reset());

  // --- Buttons: round (unaffected by objections mode) ---
  document.getElementById('roundStart').addEventListener('click', () => round.start());
  document.getElementById('roundReset').addEventListener('click', () => round.reset());

  // --- Reset all (speech + pros + def only) ---
  document.getElementById('resetAllBtn').addEventListener('click', () => {
    speech.reset();
    pros.reset();
    def.reset();
  });

  // --- Objections Mode: pause the currently running set; resume ONLY that same set ---
  let pausedSet = { speech: false, pros: false, def: false };

  function pauseCurrentSpeeches() {
    pausedSet = {
      speech: speech.running,
      pros: pros.running,
      def: def.running
    };
    // Pause only these timers (round never touched)
    speech.stop();
    pros.stop();
    def.stop();
  }

  function resumeCurrentSpeeches() {
    // Resume only what was running when you hit pause.
    if (pausedSet.speech) speech.start();
    if (pausedSet.pros) startPros();   // enforces mutual exclusion
    if (pausedSet.def) startDef();     // enforces mutual exclusion

    // Clear so you don’t accidentally resume twice later
    pausedSet = { speech: false, pros: false, def: false };
  }

  document.getElementById('objectionPause').addEventListener('click', pauseCurrentSpeeches);
  document.getElementById('objectionResume').addEventListener('click', resumeCurrentSpeeches);

  // --- Indicator ---
  function updateIndicator() {
    const running = [];
    if (speech.running) running.push('Speech');
    if (pros.running) running.push('Pros');
    if (def.running) running.push('Def');
    if (round.running) running.push('Round');
    runningIndicator.textContent = running.length ? `Running: ${running.join(', ')}` : 'All stopped';
  }
  updateIndicator();

  // --- Wake lock ---
  const wakeToggle = document.getElementById('wakeToggle');
  wakeToggle.addEventListener('change', async () => {
    if (wakeToggle.checked) {
      const ok = await requestWakeLock();
      if (!ok) wakeToggle.checked = false;
    } else {
      await releaseWakeLock();
    }
    localStorage.setItem('mt_wake', JSON.stringify({ enabled: wakeToggle.checked }));
  });

  try {
    const s = JSON.parse(localStorage.getItem('mt_wake') || '{}');
    if (s.enabled) {
      wakeToggle.checked = true;
      requestWakeLock().then(ok => { if (!ok) wakeToggle.checked = false; });
    }
  } catch {}

  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && wakeToggle.checked) {
      await requestWakeLock();
    }
  });

  // --- Service worker ---
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js').catch(() => {});
    });
  }
</script>
</body>
</html>
